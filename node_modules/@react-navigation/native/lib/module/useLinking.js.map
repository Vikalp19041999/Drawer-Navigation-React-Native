{"version":3,"sources":["useLinking.tsx"],"names":["React","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","getActionFromState","getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","prefixes","config","useEffect","Error","prefixesRef","useRef","configRef","getStateFromPathRef","getPathFromStateRef","current","getInitialState","useCallback","path","location","pathname","search","undefined","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","window","addEventListener","navigation","previousHistoryIndex","historyIndex","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","type","resetRoot","payload","dispatch","unsubscribe","addListener","previousStateLength","stateLength","l","pushState","delta","go"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    prefixes,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (isUsingLinking) {\n      throw new Error(\n        \"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts.\"\n      );\n    } else {\n      isUsingLinking = true;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const prefixesRef = React.useRef(prefixes);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    prefixesRef.current = prefixes;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, getPathFromState, getStateFromPath, prefixes]);\n\n  const getInitialState = React.useCallback(() => {\n    const path = location.pathname + location.search;\n\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    window.addEventListener('popstate', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action.type === 'RESET_ROOT') {\n            navigation.resetRoot(action.payload);\n          } else {\n            navigation.dispatch(action);\n          }\n        }\n      }\n    });\n  }, [ref]);\n\n  React.useEffect(() => {\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new enrties were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new enrties were added, pushState until we have same length\n        // This won't be accurate if multiple enrties were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = previousStateLength - stateLength;\n\n        // We need to set this to ignore the `popstate` event\n        pendingIndexChangeRef.current = index - delta;\n\n        // If new enrties were removed, go back so that we have same length\n        history.go(-delta);\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]}